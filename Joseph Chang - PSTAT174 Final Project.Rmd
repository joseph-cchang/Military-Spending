---
title: "PSTAT174 Final Project"
author: "Joseph Chang"
date: "3/11/2022"
output:
  html_document:
    code_folding: hide
df_print: paged
---

```{r setup, include=FALSE, echo = FALSE}
# set global chunk options: images will be 7x5 inches
knitr::opts_chunk$set(fig.width=7, fig.height=5, echo =TRUE, message=FALSE, warning = FALSE)
options(digits = 4)
```

```{r}
# library functions
library(knitr)
library(tidyverse) 
library(ISLR) 
library(ROCR)
library(dplyr)
library(tinytex)
library(MASS)
devtools::install_github("FinYang/tsdl")
library(tsdl)
library(forecast)
library(astsa)
library(qpcR)
```

## Executive Summary


## Introduction

The data set I plan to use is the United States military defense budget since 1960. This is essentially money the US military has used or uses for its own defense and protecting its citizens against other countries/people. Although the dataset has two other columns dedicated for population of the U.S. and GDP for each respective year, I find the defense budget column most interesting because it matches closely with the history of the United States and the wars it has participated in. Additionally, GDP and population followed a constant, linear relationship, so it was easy to predict and not as suitable for a detailed time series project.

This data is interesting to me because aside from studying statistics and data science, I have long been intrigued with history, especially US history and all the wars it has fought or participated in. This data provides me with an idea of how much the US government spent during the wars and also in the present day. For example, based from looking at the plot, I can infer that during the Vietnam War (1955-1975), the government consistently spent money to protect its own borders, and it wasn't until after 9/11 (2001) that the government began to intensify and exponentiate their spending in the years subsequently after and during the Iraq War. It wasn't until 2011 when Osama bin Laden's death led to the US to decrease their funding.

I plan to split use the original dataset to transform into another dataset. Using this new updated dataset, I will split the data into training and testing. I will use the training dataset to predict and forecast the model and compare it with the testing dataset. In the end, I will compare the testing dataset with the original dataset to make conclusions

## Data Importation

First, I read in the data and plotted a time series model for the Defense Budget each of those years. Additionally, I created a histogram to visualize the Defense Budget.

```{r}
spending_data <- read.csv("/Users/josephchang/Desktop/MilitarySpending.csv.xls")

plot(spending_data$Year, spending_data$DefenseBudget, ylab = "Defense budget (in US billion)", xlab = "Year", type="l")

plot.ts(spending_data$Year, spending_data$DefenseBudget, ylab = "Defense budget (in US billion)", xlab = "Year", type="l")

hist(spending_data$DefenseBudget, label=TRUE, main = "Histogram of US Defense Budget", breaks="Sturges", xlab = "Defense Budget (in US billion)")
```

## Testing and training for the original data

I created training and testing sets for spending_data$DefenseBudget, with the last 10 datapoints as the testing set. 

```{r}
# Define training and testing sets
training = spending_data$DefenseBudget[c(1:51)]
testing  = spending_data$DefenseBudget[c(52:61)]
```

Immediate observations: There seems to be a linear trend that is positive but there is no seasonality and no apparent sharp change in behavior. There is non-constant variance and mean. The histogram seems to be skewed right

# Transformation

Next, since the original data looked skewed, I will make any necessary transformations to make the model stationary and stabilize the variance.

```{r}
t <- 1:length(spending_data$DefenseBudget)
fit <- lm(spending_data$DefenseBudget~t)
bcTransform <- boxcox(spending_data$DefenseBudget ~ t, plotit=TRUE)
lambda = bcTransform$x[which(bcTransform$y == max(bcTransform$y))]
spent = (1/lambda)*(spending_data$DefenseBudget^lambda-1)
```

Using the Box-Cox transformation, the BcTransform command gave me the value of lambda to be around 0.30. Then I named the new transformed data using the lambda value called spent.

```{r}
# comparison of best lambda vs log/sqrt transformation
spending_data.log = log(spending_data$DefenseBudget)
spending_data.sqrt = sqrt(spending_data$DefenseBudget)

# compare transforms on time series plot
op=par(mfrow=c(2,2))
plot.ts(spending_data$DefenseBudget, main = "Original Time Series")
plot.ts(spent, main = "Box-cox Transform")
plot.ts(spending_data.log, main = "Log transform")
plot.ts(spending_data.sqrt, main = "Square root transform")
```

For comparison, I created log and square root transformations as well. In order to determine which model to use, I will create histograms of the original model vs the transformed model (spent).

```{r}
# histogram of original vs transformed
op=par(mfrow=c(1,2))
hist(spent, col = "light blue", main = "Histogram of Transformed Data")
hist(spending_data$DefenseBudget, col = "light blue", main = "Histogram of Original Data")
```

Based from the histogram, the spent dataset looked more symmetric while the original still looked skewed right. Variance also looked more stable in the transformation. As a result, the spent data looks more appropriate to use.

```{r}
# install.packages(c("ggplot2", "ggfortify"))
# library(ggplot2)
# library(ggfortify)
# y <- ts(as.ts(training))
```

## Differencing

Then, I want to check if spent needs any differencing. To start, I plotted the time series for the training set for spent differenced once, then twice, then three times. As I increased difference each time, I plotted its time series for comparison. I differenced at lag 1

```{r}
dat <- diff(training, 1)
plot.ts(dat, type= "l")
dat.2 <- diff(dat, 1)
plot.ts(dat.2, type= "l")
dat.3 <- diff(dat.2,1)
plot(dat.3, type= "l")
```

Furthermore, I checked the variance for the 3 differences. I found that when differencing twice, the minimum variance was found. At difference 3, the variance increased, so differencing at 2 is most appropriate.

```{r}
var(spent)
var(dat)
var(dat.2)
var(dat.3)
```

Since I will difference at 2, I will check the plot for dat.2, which looks somewhat stationary.

## Model Identification

For comparison, I plotted ACF and PACF for the training set of spent, spent when differenced once, and spent when differenced twice. I will compare histograms of the training, dat, dat.2.

```{r}
opar <- par(no.readonly = T)
par(mfrow=c(2,1))
acf(training, lag.max=100)
pacf(training, lag.max=100)
par(opar)

opar <- par(no.readonly = T)
par(mfrow=c(2,1))
acf(dat, lag.max = 100, main="Sample acf", ylim=c(-1,1),xlab="h", ylab= expression(hat(rho)[X](h)))
pacf(dat, lag.max=100, main="Sample pacf", ylim=c(-1,1),xlab="h", ylab= expression(hat(rho)[X](h)))
# run ACF(9) and see if coefficient is 0
# sarima (p=P=1)

opar <- par(no.readonly = T)
par(mfrow=c(2,1))
acf(dat.2, lag.max=100, main="Sample acf", ylim=c(-1,1),xlab="h", ylab= expression(hat(rho)[X](h)))
pacf(dat.2, lag.max=100, main="Sample pacf", ylim=c(-1,1),xlab="h", ylab= expression(hat(rho)[X](h)))
```

At dat.2, I noticed that for ACF, lag 9 was the furthest-most lag outside of confidence interval, and lag 1 is outside as well. For PACF, the same could be said, with lags 1 and 9 outside confidence interval

```{r}
hist(training, col = "light blue", xlab = "", main = "Histogram of original data")
hist(dat, col = "light blue", xlab = "", main = "Histogram of data differenced once")
hist(dat.2, col = "light blue", xlab = "", main = "Histogram of data differenced twice")
```

From the histogram, the original data seemed skewed right. dat.1 looked less skewed, but overall still skewed right. dat.2 looks somewhat Gaussian

## Model Estimation

Here, I will estimate coefficients of p and q. I used a for loop function to find the lowest AICc. This for loop will produce candidate models for me to run diagnostics on.

```{r}
df <- expand.grid(p=0:10, q=0:10) 
df <- cbind(df, AICc=NA)

for (i in 1:nrow(df)) {
  sarima.obj <- NULL
  try(arima.obj <- arima(training, order=c(df$p[i],2, df$q[i]), method="ML"))
  if (!is.null(arima.obj)) { df$AICc[i] <- AICc(arima.obj) }
  # print(df[i, ])
}
# this prints out the model with lowest AICc
df[which.min(df$AICc), ]

# this prints all AICc values, starting from the lowest to highest
df[order(df$AICc),]
```

Using principle of parsimony and the lowest AICC, I will consider the two best models which are (0,1) and (4,2) where p and q are respectively shown. In model 1, I found the MA coefficient to be -1, which meant I may have overdifferenced. As a result, I will revert back to differencing only once. This new model will be called new_fit1. Model 1 will use order at (1,1,1) and model 2 will use order at (0,2,1) called new_fit1 and fit2 respectively.

```{r}
# Final model 1
fit1 <- arima(training, order = c(0,2,1), method = "ML")
fit1
AICc(fit1)

new_fit1 <- arima(training, order = c(0,2,1), seasonal = list (order = c(1,0,0), period = 9), method = "ML")
new_fit1
AICc(new_fit1)

new_fit2 <- arima(training,order = c(4,2,2), seasonal = list (order = c(1,0,0), period = 9), method = "ML")
new_fit2
AICc(new_fit2)
# rerun the for loop
# stationary because less than abs 1, and all AR are invertible

# Final model 2
fit2 <- arima(training, order = c(4,2,2), method = "ML")
fit2
AICc(fit2)
# stationary because less than abs 1, and all AR are invertible

fit3 <- arima(training, order = c(1,2,1), method = "ML")
fit3
AICc(fit3)

#install.packages("unitcircle")
#library(unitcircle)

# source("plot.roots.R")
# look at gauchospace, specify the path
#plot.roots(NULL,polyroot(c(1, -0.3353, 0, -0.1612)), main="(A) roots of ma part, nonseasonal ")
```

The AICc before overdifferencing was at 26.86, but after removing differencing once, the AICc increased to 27.3. Meanwhile, Model 2 AICc was 26.86, which is now lowest of the two candidate models.

Model 1 is invertible because absolute value of coefficients for AR1 and MA1 are less than 1. Model 2 is stationary because it is purely MA. Model 2 is invertible because all roots are outside unit circle.

## Model Diagnostics for model 1

This will be model diagnostics for model 1: order = (1,1,1). For testing the independence of residuals, lag 8 is chosen because square root of observations (61) is around 8.

```{r}
# residual plots
res <- residuals(new_fit1)
mean(res)
var(res)

# layout
par(mfrow=c(1,1))
ts.plot(res, main  = "Fitted Residuals")
t <- 1:length(res)
new_fit1.res = lm(res~t)
abline(new_fit1.res)
abline(h=mean(res), col = "blue")

# Testing independence
Box.test(res, lag = sqrt(61), type = c("Box-Pierce"), fitdf = 1)
Box.test(res, lag = sqrt(61), type = c("Ljung-Box"), fitdf = 1)
Box.test(res^2, lag = sqrt(61), type = c("Ljung-Box"), fitdf = 0)

# test for normality of residuals
shapiro.test(res)

# Histogram and qq plot
par(mfrow=c(1,2))
hist(res, main= "Histogram")
qqnorm(res)
qqline(res, col = "blue")
```

Model 1 passes all tests and residuals are normal. ACF of residuals^2 shows nonlinear dependence

```{r}
# ACF and PACF of residuals
par(mfrow=c(1,2))
acf(res, main = "Autocorrelation")
pacf(res, main = "Partial Autocorrelation")
```

The ACF and PACF of residuals showed lag 9 to be outside confidence interval. Therefore, the residuals follow either a AR(9), MA(9), or ARMA(9,9) model.

```{r}
# # AR (9)
# first_fit <- arima(res, order=c(9,1,0), fixed=c(NA,0,0,0,0,0,0,NA,NA))
# acf(residuals(first_fit))
# pacf(residuals(first_fit))
# 
# # MA (9)
# second_fit <- arima(res, order=c(0,1,9), fixed=c(NA,0,0,0,0,0,0,NA,NA), method="ML")
# acf(residuals(second_fit))
# pacf(residuals(second_fit))
# 
# # ARMA(9,9)
# third_fit <- arima(res, order=c(9,1,9), fixed=c(0,0,0,0,0,0,0,0,NA,NA,0,0,0,0,0,0,0,0,NA,NA))
```

From the three models, AR(9) produced the smallest AICc.....

```{r}
# yule-walker test
ar(res, aic=TRUE, order.max = NULL, method=c("yule-walker"))
```

The fitted residuals are to AR(0), so it is white noise. This passes diagnostic checking for model 1.

## Model Diagnostics for model 2

This will be model diagnostics for model 1: order = (0,2,1)

```{r}
# residual plots
res2 <- residuals(fit2)
mean(res2)
var(res2)

# layout
par(mfrow=c(1,1))
ts.plot(res2, main  = "Fitted Residuals")
t <- 1:length(res2)
fit2.res2 = lm(res2~t)
abline(fit2.res2)
abline(h=mean(res2), col = "blue")

# Testing for independence of residuals
Box.test(res2, lag = 8, type = c("Box-Pierce"), fitdf = 2)
Box.test(res2, lag = 8, type = c("Ljung-Box"), fitdf = 2)
Box.test(res2^2, lag = 8, type = c("Ljung-Box"), fitdf = 0)

# test for normality of residuals
shapiro.test(res2)

# Histogram and qq plot
par(mfrow=c(1,2))
hist(res2, main= "Histogram")
qqnorm(res2)
qqline(res2, col = "blue")
```

Model 2 passes all tests and residuals are normal. ACF of residuals\^2 shows nonlinear dependence

```{r}
# ACF and PACF for residuals
par(mfrow=c(1,2))
acf(res2, main = "Autocorrelation")
pacf(res2, main = "Partial Autocorrelation")
```

ACF and PACF showed lag 9 to be outside confidence interval. Therefore, the residuals follow either a AR(9), MA(9), or ARMA(9,9) model, just like model 1.

```{r}
# # AR (9)
# fit_first <- arima(res2, order=c(9,2,0), fixed=c(0,0,0,0,0,0,0,NA,NA))
# acf(residuals(first_fit))
# pacf(residuals(first_fit))
# 
# # MA (9)
# fit_second <- arima(res2, order=c(0,2,9), fixed=c(0,0,0,0,0,0,0,NA,NA), method="ML")
# acf(residuals(fit_second))
# pacf(residuals(fit_second))
# 
# # ARMA(9,9)
# fit_3 <- arima(res2, order=c(9,2,9), fixed=c(0,0,0,0,0,0,0,0,NA, 0,0,0,0,0,0,0,0,NA))

```

From the three models, AR(9) produced the smallest AICc....

```{r}
# yule-walker test
ar(res2, aic=TRUE, order.max = NULL, method=c("yule-walker"))
```

## Best model

Anaylsis of residuals satisfactory?? Since both model 1 and 2 passed diagnostic checking, I will use model 2 simply due to prinicple of parsimony.

```{r}
new_fit1
# $(1-B)^2(1.643B^9)Xt$ = Zt, Zt ~ WN(0, 0.255)
```

Final model should be $(1-B)(1-0.84B)(1+0.570B^9)X_t = Z_t, Z_t ~ WN(0, 0.0625)$

## Data Forecasting

In the final step of forecasting, I will predict 10 future observations (colored in red) and plot it against the testing set of the original data (colored in blue) for comparison.

```{r}
# Predict 10 future observations and plot
par(mfrow=c(1,1))
m <- length(training)
mypred <- predict(new_fit1, n.ahead=10)
ts.plot(c(lambda*training +1)^(1/lambda), xlim=c(1, length(lambda*training)+10), ylim=c(100,200000000) , xlab = "Years after 1960", ylab = "Billions of USD")

points((m+1):(m+10), col="red", (lambda*mypred$pred +1)^(1/lambda))
points((m+1):(m+10), col="blue", (lambda*testing +1)^(1/lambda))
lines((m+1):(m+10), 
      (lambda*mypred$pred + 1.96*mypred$se+1)^(1/lambda), lty=2)
lines((m+1):(m+10), 
      (lambda*mypred$pred - 1.96*mypred$se+1)^(1/lambda), lty=2)

# original data
par(mfrow=c(2,1))
plot(spending_data$Year, spending_data$DefenseBudget, ylab = "Defense budget (in US billion)", xlab = "Year", type="l")
# transformed data
plot(spending_data$Year, spent, ylab = "Defense budget (in US billion)", xlab = "Year", type="l")
```

## Conclusion

Model 1 and 2 both passed diagnostic checking but .. Ultimately, my predicted values followed a straight linear line that would have shown increased defense funding. But, the testing dataset pointed a curve instead. Individuals who helped me on the project include Sunpeng, Youhong, and Raisa Feldman.

## References

I used this site to obtain my original dataset: <https://www.kaggle.com/brandonconrady/us-military-spending-by-year-1960-2020/version/1>

## Appendix

```{r get-labels, echo = FALSE}
labs = knitr::all_labels()
labs = setdiff(labs, c("setup", "get-labels"))
```

```{r all-code, ref.label=labs, eval=FALSE}
```
